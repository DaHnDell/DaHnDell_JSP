웹은 인터넷에서 운영되는 서비스 중 하나, 웹 자체가 인터넷을 의미하지는 않는다. 

OSI 7계층
1계층 = 물리 계층
2계층 = 
// 1~2계층 : 네트워크 인터페이스
3계층 = (라우터 포함)
// 3계층 : 인터넷 
4계층 = 전송 계층 소켓,
// 4계층 : 전송 계층
5계층 = 
6계층 = 
7계층 = 어플리케이션 계층
// 5~6~7 어플리케이션 계층

통신적 규약을 TCP-IP

멀티스레딩 ; 동시에 작업하는 것처럼 보임(실제로 동시 작업은 절대 아님)
프로세스 ; 실행 중인 프로그램 



FTP = > 21번 포트



HTML 


JSP -> 어느 구간은 HTML, 어느 구간은 HTML/

일반 HTML 파일과 다르게 위에 JSP 선언문 양식이 존재함.

MIME -> Multipurpose Internet Mail Extenstions 
다양한 유형의 정보를 식별하기 위한 표준

jsp는 서블릿이고
서블릿은 실행되어 톰캣으로 인해 전환된 자바 클래스
사실 위 두개의 내용은 정확히 똑같다.



JSP 오류 찾기
PROBLEMS 부에서 문제가 있는 부분은 다 여기서 표현됨(메세지 확인할 것)
톰캣 9.0은 타겟 런타임즈에서 체크가 안되어 있거나 하나가 아니라 여러 개가 선택되어 있을 수도 있음

집이든 학원이든 깃으로 왔다갔다 하다 보면 서버 관련해서는 문제가 생길 수도 있음

메타데이터 상의 가상 환경에서 구동되는 서버이다 보니 컴퓨터의 문제 

빌드 후 실행 가능한 파일은 자르 파일이 아니라 와르(_war) 파일
서버에 올라가는 파일은 자바 파일이 아닌 클래스 파일만 올라가게 됨.

http://localhost:8080/01_servlet/student



여기서 local호스트 = 나. 즉 이용자.

127.0.0.1

ip 주소를 알아내려면 그냥 ipconfig 사용하기.

server = 서비스 제공자. 즉, 서비스를 해주는 대상(특히 고객이 요청할 때까지)

서버를 제공한다 = 서비스 제공자를 제공한다.


프로그램 라이프사이클

보조기억장치(하드디스크) => 주기억장치(RAM)에 가져온다(변수 등등), 필요한 만큼의 자원을 운영체제에 요구한다. 
			, 할당된 자원은 프로세스 종료 시에 반납을 보장받는다.
solid, state, drive 

스레드 라이프사이클도 위와 크게 다르지 않다. 

서버와 클라이언트 간의 응답과 요청



xml이든, html이든 단 하나의 부모를 궁극적으로 가져야 한다.. 이유는 트리 구조이기 때문이다.



화면은 JSP JAVA는 서블릿


HTTP 상태 404 는 

web.xml 파일의 </welcome-file-list> 밑에다가

/*
<servlet>
    <servlet-name>test</servlet-name>
    <servlet-class>stud.MappingServlet</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>test</servlet-name>
    <url-pattern>/1234</url-pattern>
</servlet-mapping>
*/

<servlet></servlet>과 <servlet-mapping></servlet-mapping>은 한 쌍이다
위 작업 후 서버를 구동하면 로컬호스트/프로젝트이름/1234 라는 url로 웹이 켜진다
이것을 "서블릿이 url에 맵핑되었다"라고 한다

이 귀찮은 작업을 하지 않으려면 자바 클래스에다가 @WebServlet("/1234")를 쓰면 된다


자바스크립트가 자바보다 조금 느리다. 따라서 자바에서 사용했던 것을 자바스크립트에서도 사용이 가능하다.


서버가 보내는 요청을 받는 대상이 서블릿
응답이 곧 jsp가 된다.

요청처리 = 서블릿 / 응답 = jsp

논리적, 로지컬한 처리를 jsp에서 처리하려고 하면 문제가 발생할수밖에 없다. 
유지보수, 분업의 문제

@webservlet("/") 에서 / 빼먹지 않기! (주소적인 표현)





mvc = Model / View / Controller
개발 패턴 중 하나

model 1 = > 1 req-jsp = 1 resp 

model 2 = > 1 req-controller -> view = 1 resp 

model 3 = > 1 req-controller -> view or Model(DAO(DBcon), Service) ; view or Model = 1 resp

	= > 1 req-DTO -> Model(DAO(DBcon), Service return VO) ; view or DTO = 1 resp
	= > ; view ? html : REST = .jsp : JSON 

DTO -> !final + Getter + Setter.
VO -> final + only Getter.

JPA 에서는 DTO + VO = ENTITY / DAO = REPOSITORY 







서버측도 확인하고, 클라측에서도 확인하고.


jsp에서 name =>
java에서 getParameter





생성패턴에는
빌더 패턴, 팩토리 패턴, 추상화 패턴 등등 다양함. 

빌더 패턴을 사용할 경우,, 필요한 필드만 초기화해서 사용하게
할 수 있게 해줌

빌더로 호출~체이닝을 통해 필드값(설정값) 이렇게 해주고, 
맨 마지막에 build() 메서드를 호출하면 
작성한 대로의 값들로 인스턴스를 생성해줌.

setCharacterEncoding

/signin


HTTP 특성 4가지

1.client-server 구조
2.무상태성
3.비연결성
4.단순/확장 가능

tcp - 전화(1대1)(다자간이 되긴 하지만, 연결성, 전송되는 패킷의 누락 감지 지원, 편지), 
udp - 문자(일단 보내지만, 수신에 관한 답장의 예시로서 확인이 불가해짐)


HTTP는 비연결성의 특징으로서 UDP와 가까운 개념을 지님.

클라이언트의 상태가 저장되며 서버가 응답되어야 하므로 Scale-Up을 기대하기는 힘들다

정보를 계속 추가해서 요청을 보내야 하는 것이 stateless 상태.

http는 기본적으로 무상태성을 원칙으로 하는 것이 바로 그 이유.
(비용적, 경제적 측면)


스크립틀릿을 사용할 경우 
<% %>
내부에서 자바 코드 사용 가능 + 블록 레벨에서는 스코프의 열고 닫음을
추가적으로 표현이 가능 +
내부에서 선언한 변수는 무조건 지역변수가 된다.

디렉티브
<%@ %>
페이지(임포트), 인클루드(다른페이지), 태그립 사용 가능

익스프레션
<%= %>
변수 또는 그러한 값을 반환하는 메서드의 호출이 가능.
(특히 화면상의 표현을 위해)

디클라레이션
<%!  %>
전역, 혹은 클래스의 개념. 
변수를 선언할 경우에 인스턴스 변수가 됨.

JSP ---------------------------------------------------------------------------------------------
주석 <%-- --%>


Request -----------------------------------------------------------------------------------------
주소를 통해 서버를 식별함.(URL)
요청의 단위 하나는 주소 하나. 
즉, 주소가 바뀐다는 것은 요청을 했다는 뜻
이미지를 가져오거나, 외부 css 를 가져온다는 것은 전부 다 요청에 해당한다. 
get / post / delete 
경로 / 서블릿 이름 ? 이름 = 값 & 이름
서블릿에서의 request 객체 호출을 통해 getParameter / getMethod 등의 메서드 호출 가능.
getParameterValues = 스트링 배열을 반환

form 태그를 post로 처리하게 되면 
한글 깨짐 현상이 생긴다 => request.setCharacterEncoding("utf-8");로 인코딩을 해 주어야 한다

get 방식의 파라미터 처리는 언제나 쿼리스트링으로 처리한다. 새로 고침을 해도 양식 새로 제출, 
url 형식으로 값을 직접 입력해도 처리함.


set => 단순히 생각했을 때+집합. 순서 보장 x + 중복 불가

map => set 에다가 밸류의 중복 처리를 위해 키(주소값)를 추가하여 키와 밸류의 값으로 저장.
(단, map에서의 키값은 set이다. 중복 불가 + 순서를 보장하지 않기 때문. 
그래서 add가 아니라 push 메서드를 활용하는 것.)

list => set 에다가 밸류의 중복 처리를 위해 인덱스(주소값)를 추가하여 저장.

set의 특성상 순서가 보장되지 않으므로 검색을 위한 이터레이터, 순환자가 필요.
hasnext() => 다음 값에 따른 불린값 반환. 있으면 t, 없으면 f
next() => 주소값을 따라가며 다음 값을 반환.



enumeration / iterator(순환자 => 자료구조(set, list 등), 즉 포인터)
vector / Arraylist
hashtable / hashmap

request의 유효 권한은 주소값이 달라지기 전까지. 즉, 자기 페이지(jsp)에서만 효력을 발휘한다.
만약 다른 페이지에서도 권한이 발동하려면 session을 활용해야만 한다.

include, forward --------------------------------------------------------------------------------
include는 포함하다, 즉 jsp에 jsp 파일을 포함하는 것이다. 
jsp 파일을 적절한 편집을 통해 모듈화처럼 활용할 수 있다.
반복되는 작업을 이러한 형식으로 처리하는 것을 spring에서는 tiles 라고 한다.

forward는 주소가 안바뀌는데 응답만 바뀐다. 즉, 요청은 그대로인데 응답만 바뀐다.
즉 request의 유효 권한을 변경하지 않으면서 다른 실행을 하기 위해서 사용한다.
특히 게시판에서 사용한다,,?


-------------------------------include + forward = 결국 1 req를 가지고 공유하는 것 -------------



--------- page - request - session - application ---------
${} el 문법으로 하위 요소부터 일치하는 값을 쭉 찾다가 위로까지 올라감.

어플리케이션 = 서버 구동 중 전역값.

html에서 이동 방식 ------------------------------------------------------------------------------

<a 태그 + href = "url"
<form + button(submit)>

java에서는 response.sendRedirect("url")

url이 바뀌었다 ? 요청이 바뀌었다 + 주소가 바뀌었다 + 응답도 당연히 바뀌었다.






마이바티스 / jpa


클라이언트 측에서의 언어 = 자바스크립트.
서버 측에서의 언어 = jsp가 세션 담당

쿠키를 가져오기 위해 
쿠키는 브라우저가 꺼지기 전까지 가지고 있음. 
서버에서 쿠키를 생성 -> 쿠키를 응답 헤더에 넣어 클라이언트로 전송 -> 웹 브라우저는 쿠키를 하드 디스크 혹은 브라우저 메모리에 저장  ->  쿠키에 지정된 경로에 요청 시 받은 쿠키를 서버에 전송



value = 
       	    	if($.cookie("id")){
       	   			$("#id").attr("placeholder", "<%=m.getName()%>");
       	   		}

Cookie cookie = new Cookie("id", null);
cookie.setValue(service.findBy(id).getId());
resp.sendRedirect(req.getContextPath()+"/index");


el은 단순 출력도 가능하지만, 사칙, 비교, 논리, 3항 연산 등을 지원한다. 이러한 연산 기능은 핵심 로직의 구현보다는 상황에 따라 출력값을 변경하는 정도의 용도로 사용하는 것이 좋다. 

데이터가 없거나 null 객체를 참조할 때에도 에러가 발생하지 않는다.



winnetstate


설계_테스트_구현(모듈화 방식)
이러한 모듈 하나하나가 서비스가 됨




리퍼러, 헤더에 포함되어 있는 이전 리퀘스트 정보의 주소로 
어디서 어느 경로로 왔는지 알 수 있음.

jstl = fmt, fn 등의 기능들도 있음.



contextpath = /member_post

현재 위치랑 한 페이지당 개수




lazyload = 이미지 등 서버에 부하가 큰 작업들을 천천히 하는 작업. 사용자는 보통 앞부분만 보고 휙 돌아가기 때문에 아래 이미지까지 로드하지 않는 것이 대표적인 예시이다.

String 에서의 join 메서드는 배열을 합쳐 하나의 문자열로 바꾼다.

post 방식에 대한 처리는 input 태그를 통해 해야만 한다. 왜냐하면 그냥 get 방식으로 할 경우는 사용자의 입력 폼을 송신하지를 못하기 때문이다.




UUID


Mybatis - sql Mapper(맵퍼 중 가장 유명하고 강력함)
구문을 직접 작성하는 데에는 훨씬 강력하다. 엄청난 프레임워크!!
마이바티스의 핵심 구문 객체는 SqlSession을 사용한다. 
독립된 형태의 파일이고 이를 통해 맵퍼를 통해 파일을 가져온다.
DTD 형태의 파일이 허가한 종류에서만 태그를 제어할 수 있다. 
<mapper namespace = > 태그를 활용해서 mapper의 주소를 작성할 수 있다.


갤러리 + 게시판
위치 기반 + 게시판
주변 + 공공데이터(고령화 관련) + 게시판








요구사항 수집 및 분석, 기획
(요구사항 정의서)

화면 UI 설계
(디지털 프로토타입)
- 적절한 툴을 구할 수 없다면 파워포인트로 한다

ERD 데이터베이스 설계
+ 태이블 명세서(정의서)


HTML CSS JavaScript Jquery 이용

MVC 디자인 패턴 설계(DAO VO DTO)

git, github를 이용한 협업개발
+ git MD 작성

발표자료

테스트 도구를 이용한 웹 어플리케이션 테스트 및 배포(하지 않을 예정)

최종 결과물에 대한 발표 자료 제작 및 발표







mapper -> resultmap 에서 Id가 PK가 됨.

type 에선 vo 위치 적기.
map 에선 map 이름 적기.



비동기 처리
장점 - 클라쪽 코드가 복잡해지지만, 유지보수가 간결해짐.
REST 형식의 파일이고, JSON에 업로드할 파일의 정보.
]
unicode (기반)
utf 8 한글 - (3byte)
utf 16 한글 - (1byte)

mb4 - 이모지까지 표현해서 한 글자 4바이트


레스트 처리를 할때 URI 수정하는 것이 매우중요



inputStream = > read 하는 애.
reader = > read 하는 애
read = > 메서드

OutputStream = > write 하는 애.


json 자체의 문제 때문에 {\"content\" 식으로 } 작성해 줘야 함. 특히 한글의 경우 더 심각해짐.
