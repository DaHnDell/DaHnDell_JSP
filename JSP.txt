웹은 인터넷에서 운영되는 서비스 중 하나, 웹 자체가 인터넷을 의미하지는 않는다. 

OSI 7계층
1계층 = 물리 계층
2계층 = 
// 1~2계층 : 네트워크 인터페이스
3계층 = (라우터 포함)
// 3계층 : 인터넷 
4계층 = 전송 계층 소켓,
// 4계층 : 전송 계층
5계층 = 
6계층 = 
7계층 = 어플리케이션 계층
// 5~6~7 어플리케이션 계층

통신적 규약을 TCP-IP

멀티스레딩 ; 동시에 작업하는 것처럼 보임(실제로 동시 작업은 절대 아님)
프로세스 ; 실행 중인 프로그램 



FTP = > 21번 포트



HTML 


JSP -> 어느 구간은 HTML, 어느 구간은 HTML/

일반 HTML 파일과 다르게 위에 JSP 선언문 양식이 존재함.

MIME -> Multipurpose Internet Mail Extenstions 
다양한 유형의 정보를 식별하기 위한 표준

jsp는 서블릿이고
서블릿은 실행되어 톰캣으로 인해 전환된 자바 클래스
사실 위 두개의 내용은 정확히 똑같다.


















JSP 오류 찾기
PROBLEMS 부에서 문제가 있는 부분은 다 여기서 표현됨(메세지 확인할 것)
톰캣 9.0은 타겟 런타임즈에서 체크가 안되어 있거나 하나가 아니라 여러 개가 선택되어 있을 수도 있음

집이든 학원이든 깃으로 왔다갔다 하다 보면 서버 관련해서는 문제가 생길 수도 있음

메타데이터 상의 가상 환경에서 구동되는 서버이다 보니 컴퓨터의 문제 

빌드 후 실행 가능한 파일은 자르 파일이 아니라 와르(_war) 파일
서버에 올라가는 파일은 자바 파일이 아닌 클래스 파일만 올라가게 됨.

http://localhost:8080/01_servlet/student



여기서 local호스트 = 나. 즉 이용자.

127.0.0.1

ip 주소를 알아내려면 그냥 ipconfig 사용하기.

server = 서비스 제공자. 즉, 서비스를 해주는 대상(특히 고객이 요청할 때까지)

서버를 제공한다 = 서비스 제공자를 제공한다.


프로그램 라이프사이클

보조기억장치(하드디스크) => 주기억장치(RAM)에 가져온다(변수 등등), 필요한 만큼의 자원을 운영체제에 요구한다. 
			, 할당된 자원은 프로세스 종료 시에 반납을 보장받는다.
solid, state, drive 

스레드 라이프사이클도 위와 크게 다르지 않다. 

서버와 클라이언트 간의 응답과 요청



xml이든, html이든 단 하나의 부모를 궁극적으로 가져야 한다.. 이유는 트리 구조이기 때문이다.



화면은 JSP JAVA는 서블릿


HTTP 상태 404 는 

web.xml 파일의 </welcome-file-list> 밑에다가

/*
<servlet>
    <servlet-name>test</servlet-name>
    <servlet-class>stud.MappingServlet</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>test</servlet-name>
    <url-pattern>/1234</url-pattern>
</servlet-mapping>
*/

<servlet></servlet>과 <servlet-mapping></servlet-mapping>은 한 쌍이다
위 작업 후 서버를 구동하면 로컬호스트/프로젝트이름/1234 라는 url로 웹이 켜진다
이것을 "서블릿이 url에 맵핑되었다"라고 한다

이 귀찮은 작업을 하지 않으려면 자바 클래스에다가 @WebServlet("/1234")를 쓰면 된다


자바스크립트가 자바보다 조금 느리다. 따라서 자바에서 사용했던 것을 자바스크립트에서도 사용이 가능하다.


서버가 보내는 요청을 받는 대상이 서블릿
응답이 곧 jsp가 된다.

요청처리 = 서블릿 / 응답 = jsp

논리적, 로지컬한 처리를 jsp에서 처리하려고 하면 문제가 발생할수밖에 없다. 
유지보수, 분업의 문제

@webservlet("/") 에서 / 빼먹지 않기!









서버측도 확인하고, 클라측에서도 확인하고.


jsp에서 name =>
java에서 getParameter



생성패턴에는
빌더 패턴, 팩토리 패턴, 추상화 패턴 등등 다양함. 

빌더 패턴을 사용할 경우,, 필요한 필드만 초기화해서 사용하게
할 수 있게 해줌

빌더로 호출~체이닝을 통해 필드값(설정값) 이렇게 해주고, 
맨 마지막에 build() 메서드를 호출하면 
작성한 대로의 값들로 인스턴스를 생성해줌.

setCharacterEncoding

/signin


HTTP 특성 4가지

1.client-server 구조
2.무상태성
3.비연결성
4.단순/확장 가능

tcp - 전화(1대1)(다자간이 되긴 하지만, 연결성, 전송되는 패킷의 누락 감지 지원, 편지), udp - 문자(일단 보내지만, 수신에 관한 답장의 예시로서 확인이 불가해짐)

HTTP는 비연결성의 특징으로서 UDP와 가까운 개념을 지님.

클라이언트의 상태가 저장되며 서버가 응답되어야 하므로 Scale-Up을 기대하기는 힘들다

정보를 계속 추가해서 요청을 보내야 하는 것이 stateless 상태.

http는 기본적으로 무상태성을 원칙으로 하는 것이 바로 그 이유.
(비용적, 경제적 측면)


스크립틀릿을 사용할 경우 
<% %>
내부에서 선언한 변수는 무조건 지역변수가 된다.

디렉티브
<%@ %>
페이지(임포트), 인클루드(다른페이지), 태그립

익스프레션
<%= %>
변수 또는 그러한 값을 반환하는 메서드의 호출이 가능.
(특히 화면상의 표현을 위해)

디클라레이션
<%!  %>
전역, 혹은 클래스의 개념. 
변수를 선언할 경우에 인스턴스 변수가 됨.
